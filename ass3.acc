/**
 * The Duff parser: a C-parser-to-LaTeX-pretty-printer
 * by Marco Gunnink (2170248) and Bart Offereins (2255243)
*/

%prelude{
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "parser.h"
	
	extern FILE * out;
	
	void escapeChar(FILE * out, int c){
		switch(c){
			case '\\':
				fputs("\\textbackslash ", out);
			break;
			
			case '<':
			case '>':
				fputc('$', out);
				fputc(c, out);
				fputc('$', out);
			break;
			
			case '&':
			case '%':
			case '{':
			case '}':
			case '_':
				fputc('\\', out);
			/* fall-through: w00t! */
			default:
				fputc(c, out);
		}
	}
	
	void escapeString(FILE * out, char * s){
		while(*s) escapeChar(out, *s++);
	}
	
	void printSubtype(FILE * out, int st){
		fputs("\\ $", out);
		switch(st){
			case COMPARE_EQUAL: fputs("==", out); break;
			case COMPARE_UNEQUAL: fputs("\\neq", out); break;
			case COMPARE_LEQ: fputs("\\leq", out); break;
			case COMPARE_GREQ: fputs("\\geq", out); break;
			case COMPARE_GREATER: fputs(">", out); break;
			case COMPARE_LESS: fputs("<", out); break;
			
			case ASSIGN_AND: fputs("\\&=", out); break;
			case ASSIGN_DIVIDE: fputs("/=", out); break;
			case ASSIGN_MINUS: fputs("-=", out); break;
			case ASSIGN_MOD: fputs("\\%=", out); break;
			case ASSIGN_OR: fputs("|=", out); break;
			case ASSIGN_PLUS: fputs("+=", out); break;
			case ASSIGN_SHLEFT: fputs("<<=", out); break;
			case ASSIGN_SHRIGHT: fputs(">>=", out); break;
			case ASSIGN_XOR: fputs("\\^=", out); break;
			
			case ASSIGN_SWAP: fputs("\\leftrightarrow", out); break;
		}
		fputs("$\\ ", out);
	}
	
	/* Nice cryptic macros for shortening semantic-action blocks */
	#define PRCH escapeChar(out, yylval.c)
	#define PRCHS PRCH, fputs("\\ ", out)
	/* long live the comma-operator! */
	#define SPRCHS fputs("\\ ", out), PRCHS
	#define PRS escapeString(out, yylval.s)
	#define PRKW fprintf(out, "{\\bf %s} ", yylval.s)
	#define PRSC fputs(";\\\\\n", out)
}

%token AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, 
	DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, 
	RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, 
	UNSIGNED, VOID, VOLATILE, WHILE, CONSTANT, STRING, ELLIPSIS, 
	ASSIGN, COMPARE, ARIT_OP, INC_OP, DEC_OP, PTR_OP, LOGICAL_OR, LOGICAL_AND, IDENTIFIER, SHIFT, INCLUDE, CHARACTER, FLOATCONST, INTCONST, PRINT, INPUT, EXP;

/* Rules: heavily modified, based on the official grammar as found in K&R ANSI-C second edition (Â§A13). */
translation_unit
	: ( external_declaration )*
	;
	
external_declaration
	: function_definition
	| declaration
	;
	
function_definition
	: ( declaration_specifiers )? declarator ( declaration_list )? ( ';' | compound_statement )
	;
	
declaration
	: declaration_specifiers ( init_declarator_list )? ';'
	;
	
declaration_list
	: declaration ( declaration )*
	;
	
declaration_specifiers
	: ( storage_class_specifier | type_specifier | type_qualifier )*
	;

storage_class_specifier
	: ( AUTO
	| REGISTER
	| STATIC
	| EXTERN
	| TYPEDEF )
	;

/*typedef-name replaced with 'id' */
type_specifier
	: ( VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED )
	| struct_or_union_specifier | enum_specifier
	| id<i> {}
	;
	
type_qualifier
	: ( CONST
	| VOLATILE )
	;

struct_or_union_specifier
	: struct_or_union ( id<i> )? '{' struct_declaration_list '}'
	| struct_or_union id<i> {}
	;
	
struct_or_union
	: ( STRUCT | UNION )
	;
	
struct_declaration_list
	: ( struct_declaration_list )? struct_declaration 
	;
	
init_declarator_list
	: ( init_declarator_list ',' )? init_declarator
	;
	
init_declarator
	: ( declarator '=' )? initializer
	;
	
struct_declaration
	: specifier_qualifier_list struct_declarator_list ';'
	;

specifier_qualifier_list
	: ( type_specifier | type_qualifier ) ( specifier_qualifier_list )?
	;

struct_declarator_list
	: ( struct_declarator_list ',' )? struct_declarator
	;
	
struct_declarator
	: declarator
	| ( declarator )? ':' constant_expression<ce>
	;

enum_specifier
	: ENUM ( id<i> )? '{' enumerator_list '}'
	| ENUM id<i>
	;
	
enumerator_list
	: ( enumerator_list ',' )? enumerator
	;
	
enumerator
	: id<i> ( '=' constant_expression<ce> )?
	;
	
declarator
	: ( pointer )? direct_declarator
	;
	
direct_declarator
	: id<i>
	| '(' declarator ')'
	| direct_declarator ( '[' ( expression<e> )? ']'
		| '(' parameter_type_list ')'
		| '(' ( identifier_list )? ')' )
	;
	
pointer
	: '*' ( type_qualifier_list )? ( pointer )?
	;
	
type_qualifier_list
	: ( type_qualifier_list )? type_qualifier
	;
	
parameter_type_list
	: parameter_list ( ',' ELLIPSIS )?
	;

parameter_list
	: ( parameter_list ',' )? parameter_declaration
	;
	
parameter_declaration
	: declaration_specifiers ( declarator | ( abstract_declarator )? )
	;
	
identifier_list
	: ( identifier_list ',' )? id<i>
	;
	
initializer
	: assignment_expression<ae>
	| '{' initializer_list ( ',' )? '}'
	;
	
initializer_list
	: ( initializer_list ',' )? initializer
	;
	
type_name
	: specifier_qualifier_list ( abstract_declarator )?
	;
	
abstract_declarator
	: pointer
	| ( pointer )? direct_abstract_declarator
	;
	
direct_abstract_declarator
	: '(' abstract_declarator ')'
	| ( direct_abstract_declarator )? ( '[' ( expression<e> )? ']'
		| '(' ( parameter_type_list )? ')' )
	;
	
typedef_name
	: id<i>
	;
	
statement
	: labeled_statement
	| expression_statement
	| compound_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	| print_statement
	| input_statement
	;
	
labeled_statement
	: id<i> ':' statement	/* warning: labels & GOTO's make Dijkstra angry! */
	| CASE constant_expression<ce> ':' statement
	| DEFAULT ':' statement
	;
	
expression_statement
	: ( expression<e> )? ';'
	;
	
compound_statement
	: '{' ( declaration_list )? ( statement_list )? '}'
	;
	
 /* statement_or_declaration
	: statement
	| declaration
	; */
	
statement_list
	: ( statement )* statement
	;
	
selection_statement
	: IF '(' expression<e> ')' statement ( ELSE statement )?
	| SWITCH '(' expression<e> ')' statement
	;

iteration_statement
	: WHILE '(' { PRCH; } expression<e> ')' { PRCH; } statement
	| DO { PRKW; } statement WHILE { PRKW; } '(' { PRCH; } expression<e> ')' { PRCH; } ';'
	| FOR { PRKW; } '(' { PRCH; } ( expression<e> )? ';' ( expression<e> )? ';' ( expression<e> )? ')' { PRCH; } statement
	;
	
jump_statement
	: GOTO { PRKW; } id<i> ';' /* warning: labels & GOTO's make Dijkstra angry! */
	| CONTINUE { PRKW; } ';'
	| BREAK { PRKW; } ';'
	| RETURN { PRKW; } ( expression<e> )? ';'
	;

print_statement
	: PRINT { PRKW; } argument_expression_list<ae> ';'
	;
	
input_statement
	: INPUT { PRKW; } ( id<i> ',' )* id<i> ';'
	;
	
expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, ','); } ( expression<e> { appendExpression(*ret, e); } ',' )? assignment_expression<ae> { appendExpression(*ret, ae); printExpression(*ret); }
	;

assignment_expression<%out expression_pt ret>
	: conditional_expression<ce> { *ret = ce; }
	| { *ret = makeExpression(1, 0, '='); } unary_expression<ue> { appendExpression(*ret, ue); } assignment_operator assignment_expression<ae> { appendExpression(*ret, ae); }
	;
	
assignment_operator
	: ASSIGN
	| '='
	;
	
conditional_expression<%out expression_pt ret>
	: logical_OR_expression<loe> { *ret = loe; }
	| logical_OR_expression<loe> '?' expression<e> ':' conditional_expression<ce> { *ret = makeExpression(1, 3, '?', loe, e, ce); }
	;
	
constant_expression<%out expression_pt ret>
	: conditional_expression<ce> { *ret = ce; }
	;
	
logical_OR_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, '||'); } ( logical_OR_expression<loe> { appendExpression(*ret, loe); } LOGICAL_OR )? logical_AND_expression<lae> { appendExpression(*ret, lae); }
	;
	
logical_AND_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, '&&'); } ( logical_AND_expression<lae> { appendExpression(*ret, lae); } LOGICAL_AND )? inclusive_OR_expression<ioe> { appendExpression(*ret, ioe); }
	;

inclusive_OR_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, '|'); } ( inclusive_OR_expression<ioe> { appendExpression(*ret, ioe); } '|' )? exclusive_OR_expression<eoe> { appendExpression(*ret, eoe); }
	;
	
exclusive_OR_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, '^'); } ( exclusive_OR_expression<eoe> { appendExpression(*ret, eoe); } '^' )? AND_expression<ae> { appendExpression(*ret, ae); }
	;
	
AND_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, '&'); } (AND_expression<ae> { appendExpression(*ret, ae); } '&' )? equality_expression<ee> { appendExpression(*ret, ee); }
	;
	
equality_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, 0); } ( equality_expression<ee> { appendExpression(*ret, ee); } COMPARE )? shift_expression<se> { appendExpression(*ret, se); }
	;

shift_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, 0); } (shift_expression<se> { appendExpression(*ret, se); } SHIFT )? additive_expression<ae> { appendExpression(*ret, ae); }
	;
	
additive_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, 0); } ( additive_expression<ae> { appendExpression(*ret, ae); } ( '+' | '-' ) )? multiplicative_expression<me> { appendExpression(*ret, me); }
	;
	
multiplicative_expression<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, 0); } ( multiplicative_expression<me> { appendExpression(*ret, me); } ( '*' | '/' | '%' ) )? cast_expression<ce> { appendExpression(*ret, ce); }
	;
	
cast_expression<%out expression_pt ret>
	: unary_expression<ue> { *ret =  ue; }
	| '(' type_name ')' cast_expression<ce> { *ret = ce; }
	;
	
unary_expression<%out expression_pt ret>
	: postfix_expression<pe> { *ret = pe; }
	| { int t; } ( INC_OP {t = '++x';} | DEC_OP {t = '--x'; } ) unary_expression<ue> { *ret = makeExpression(1, 1, t, ue); }
	| unary_operator cast_expression<ce>
	| SIZEOF unary_expression<ue>
	| SIZEOF '(' type_name ')'
	;
	
unary_operator
	: ('&' | '*' | '+' | '-' | '~' | '!' | '~' | '|' | '^')
	;
	
postfix_expression<%out expression_pt ret>
	: primary_expression<pe> { *ret = pe; }
	| postfix_expression<pe> { *ret = makeExpression(1, 1, 0, pe); }
		( '[' expression<e> { appendExpression(*ret, e); } ( ':' expression<e> { appendExpression(*ret, e); } )? ']'
		| '(' ( argument_expression_list<ae> { appendExpression(*ret, ae); } )? ')' { (*ret)->operator = '()'; }
		| '.' id<i> { appendExpression(*ret, makeExpression(0, 1, 0, i)); (*ret)->operator = '.'; }
		| PTR_OP id<i> { appendExpression(*ret, makeExpression(0, 1, 0, i)); (*ret)->operator = '->'; }
		| INC_OP { (*ret)->operator = 'x++'; } 
		| DEC_OP { (*ret)->operator = 'x--'; } 
		)
	;
	
primary_expression<%out expression_pt ret>
	: id<i> { *ret = makeExpression(0, 1, 0, i); printExpression(*ret); putchar('\n'); }
	| constant<c> { *ret = makeExpression(0, 1, 0, c); }
	| '(' expression<e> { *ret = e; } ')'
	;
	
argument_expression_list<%out expression_pt ret>
	: { *ret = makeExpression(1, 0, 0); }( assignment_expression<ae> { growExpression(*ret); (*ret)->value[(*ret)->length-1].e = ae; } ',' )* assignment_expression<ae2> { growExpression(*ret); (*ret)->value[(*ret)->length-1].e = ae2; }
	;
	
constant<%out constant_pt ret>
	: INTCONST { fprintf(out, "$%lu$", yylval.i); *ret = makeIntConst(yylval.i); }
	| CHARACTER { *ret = makeIntConst(yylval.i); }
	| FLOATCONST { fprintf(out, "$%f$", yylval.d); *ret = makeFloatConst(yylval.d); }
	| STRING { *ret = makeStringConst(yylval.s); }
	/* | id enumeration-constant..? Should check against defined enum-constants... Yeah, no */
	;
	
id<%out constant_pt ret>
	: IDENTIFIER { *ret = makeStringConst(yylval.s); (*ret)->type = IDCONST; }
	;
