%prelude{
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "parser.h"
	
	extern FILE * f;
	
	void fprintStringConst(FILE * f, char * s){
		while(*s){
			if(*s == '\\') fputs("\\textbackslash ", f);
			else if(*s == '%') fputs("\\%", f);
			else fputc(*s, f);
			s++;
		}
	}
	
	void fprintIdentifier(FILE * f, char * s){
		while(*s){
			if(*s == '_') fputc('\\', f), fputc('_', f);
			else fputc(*s, f);
			s++;
		}
	}
	
	void prCh(FILE * f, int c){
		switch(c){
			case '&':
			case '%':
			case '{':
			case '}':
				fputc('\\', f);
				fputc(c, f);
			break;
			case '<':
			case '>':
				fputc('$', f);
				fputc(c, f);
				fputc('$', f);
			break;
			default:
				fputc(c, f);
		}
	}
	
	void fprintCompare(FILE * f, int st){
		switch(st){
			case COMPARE_EQUAL: fputs("\\ $==$\\ ", f); break;
			case COMPARE_UNEQUAL: fputs("\\ $\\neq$\\ ", f); break;
			case COMPARE_LEQ: fputs("\\ $\\leq$\\ ", f); break;
			case COMPARE_GREQ: fputs("\\ $\\geq$\\ ", f); break;
			case COMPARE_GREATER: fputs("\\ $>$\\ ", f); break;
			case COMPARE_LESS: fputs("\\ $<$\\ ", f); break;
		}
	}
	
	#define PRCHS prCh(f, yylval.c), fprintf(f, "\\ ")
	#define PRCH prCh(f, yylval.c)
	#define PRS fprintStringConst(f, yylval.s)
	#define PRKW fprintf(f, "{\\bf %s} ", yylval.s)
}

%token AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, 
	DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, 
	RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, 
	UNSIGNED, VOID, VOLATILE, WHILE, CONSTANT, STRING, ELLIPSIS, 
	ASSIGN, COMPARE, ARIT_OP, INC_OP, DEC_OP, PTR_OP, LOGICAL_OR, LOGICAL_AND, IDENTIFIER, 
	PREPROC, BIT_OR, BIT_AND, BIT_XOR, SHIFT, INCLUDE, CHARACTER, FLOATCONST, INTCONST;

/* Rules */
translation_unit
	: ( external_declaration )*
	| include_line
	;
	
include_line
	: '#' { PRCH; } INCLUDE { PRKW; } ( STRING { fprintStringConst(f, yylval.s); }  ) /* Spoort niet */
	;
	
external_declaration
	: function_definition
	| declaration
	;
	
function_definition
	: ( declaration_specifiers )? declarator ( declaration_list )? compound_statement { fputs("\\\\\n", f); }
	;
	
declaration
	: declaration_specifiers ( init_declarator_list )? ';' { fputs(";\\\\\n", f); }
	;
	
declaration_list
	: ( declaration_list )? declaration
	;
	
declaration_specifiers
	: ( storage_class_specifier | type_specifier | type_qualifier ) ( declaration_specifiers )?
	;

storage_class_specifier
	: ( AUTO
	| REGISTER
	| STATIC
	| EXTERN
	| TYPEDEF ) { PRKW; }
	;
	/*typedef-name removed*/
type_specifier
	: ( VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED ) { PRKW; }
	| struct_or_union_specifier | enum_specifier
	;
	
type_qualifier
	: ( CONST
	| VOLATILE ) { PRKW; }
	;

struct_or_union_specifier
	: struct_or_union ( id )? '{' { fputs("\\{\\\\\n", f); } struct_declaration_list '}' { fputs("\\}\\\\\n", f); }
	| struct_or_union id
	;
	
struct_or_union
	: ( STRUCT | UNION ) { PRKW; }
	;
	
struct_declaration_list
	: ( struct_declaration_list )? struct_declaration 
	;
	
init_declarator_list
	: ( init_declarator_list ',' { PRCHS; } )? init_declarator
	;
	
init_declarator
	: ( declarator '=' { PRCH; } )? initializer
	;
	
struct_declaration
	: specifier_qualifier_list struct_declarator_list ';' { fputs(";\\\\\n", f); }
	;

specifier_qualifier_list
	: ( type_specifier | type_qualifier ) ( specifier_qualifier_list )?
	;

struct_declarator_list
	: ( struct_declarator_list ',' { PRCHS; } )? struct_declarator
	;
	
struct_declarator
	: declarator
	| ( declarator )? ':' { PRCH; } constant_expression
	;

enum_specifier
	: ENUM ( id )? { fputs("\\{\\\\\n", f); } '{' enumerator_list '}' { fputs("\\}\\\\\n", f); }
	| ENUM id
	;
	
enumerator_list
	: ( enumerator_list ',' { PRCHS; } )? enumerator
	;
	
enumerator
	: id ( '=' { PRCH; } constant_expression )?
	;
	
declarator
	: ( pointer )? direct_declarator
	;
	
direct_declarator
	: id  {printf("Identifier within declarator: %s\n", yylval.s);}
	| '(' { PRCH; } declarator ')' { PRCH; }
	| direct_declarator ( '[' { PRCH; } ( constant_expression )? ']' { PRCH; } | '(' { PRCH; } parameter_type_list ')' { PRCH; } | '(' { PRCH; } ( identifier_list )? ')' { PRCH; } )
	;
	
pointer
	: '*' { PRCH; } ( type_qualifier_list )? ( pointer )?
	;
	
type_qualifier_list
	: ( type_qualifier_list )? type_qualifier
	;
	
parameter_type_list
	: parameter_list ( ',' { PRCHS; } ELLIPSIS )?
	;

parameter_list
	: ( parameter_list ',' { PRCHS; } )? parameter_declaration
	;
	
parameter_declaration
	: declaration_specifiers ( declarator | ( abstract_declarator )? )
	;
	
identifier_list
	: ( identifier_list ',' { PRCHS; } )? id
	;
	
initializer
	: assignment_expression
	| '{' { fputs("\\{", f); } initializer_list ( ',' )? '}' { fputs("\\}", f); }
	;
	
initializer_list
	: ( initializer_list ',' { PRCHS; } )? initializer
	;
	
type_name
	: specifier_qualifier_list ( abstract_declarator )?
	;
	
abstract_declarator
	: pointer
	| ( pointer )? direct_abstract_declarator
	;
	
direct_abstract_declarator
	: '(' { PRCH; } abstract_declarator ')' { PRCH; }
	| ( direct_abstract_declarator )? ( '[' { PRCH; } ( constant_expression )? ']' { PRCH; } | '(' { PRCH; } ( parameter_type_list )? ')' { PRCH; } )
	;
	
typedef_name
	: id
	;
	
statement
	: labeled_statement
	| expression_statement
	| compound_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;
	
labeled_statement
	: id ':' { PRCH; } statement	/* warning: labels & GOTO's make Dijkstra angry! */
	| CASE { PRKW; } constant_expression ':' { PRCH; } statement
	| DEFAULT { PRKW; } ':' { PRCH; } statement
	;
	
expression_statement
	: ( expression )? ';' { fputs(";\\\\\n", f); }
	;
	
compound_statement
	: '{' { fputs("\\{\\\\\n", f); } ( declaration_list )? ( statement_list )? '}' { fputs("\\}\\\\\n", f); }
	;
	
statement_list
	: ( statement_list )? statement
	;
	
selection_statement
	: IF { PRKW; } '(' { PRCH; } expression ')' { PRCH; } statement ( ELSE { PRKW; } statement )?
	| SWITCH { PRKW; } '(' { PRCH; } expression ')' { PRCH; } statement
	;

iteration_statement
	: WHILE { PRKW; } '(' { PRCH; } expression ')' { PRCH; } statement
	| DO { PRKW; } statement WHILE { PRKW; } '(' { PRCH; } expression ')' { PRCH; } ';' { fputs(";\\\\\n", f); }
	| FOR { PRKW; } '(' { PRCH; } ( expression )? ';' { PRCH; } ( expression )? ';' { PRCH; } ( expression )? ')' { PRCH; } statement
	;
	
jump_statement
	: GOTO { PRKW; } id ';' { fputs(";\\\\\n", f); } /* warning: labels & GOTO's make Dijkstra angry! */
	| CONTINUE { PRKW; } ';' { fputs(";\\\\\n", f); }
	| BREAK { PRKW; } ';' { fputs(";\\\\\n", f); }
	| RETURN { PRKW; } ( expression )? ';' { printf("Return\n"); fputs(";\\\\\n", f); }
	;
	
expression
	: ( expression ',' { PRCHS; } )? assignment_expression
	;

assignment_expression
	: conditional_expression
	| unary_expression assignment_operator assignment_expression
	;
	
assignment_operator
	: ( ASSIGN 
	| '=' ) { fputc(' ', f); PRCHS; }
	;
	
conditional_expression
	: logical_OR_expression ( '?' { PRCH; } expression ':' { PRCH; } conditional_expression )?
	;
	
constant_expression
	: conditional_expression
	;
	
logical_OR_expression
	: ( logical_OR_expression LOGICAL_OR )? logical_AND_expression
	;
	
logical_AND_expression
	: ( logical_AND_expression LOGICAL_AND )? inclusive_OR_expression
	;

inclusive_OR_expression
	: ( inclusive_OR_expression BIT_OR )? exclusive_OR_expression
	;
	
exclusive_OR_expression
	: ( exclusive_OR_expression BIT_XOR )? AND_expression
	;
	
AND_expression
	: (AND_expression BIT_AND )? equality_expression
	;
	
equality_expression
	: ( equality_expression COMPARE { fprintCompare(f, yylval.subtype); } )? shift_expression
	;

shift_expression
	: (shift_expression SHIFT )? additive_expression
	;
	
additive_expression
	: ( additive_expression ( '+' | '-' ) { PRCH; } )? multiplicative_expression
	;
	
multiplicative_expression
	: ( multiplicative_expression ( '*' | '/' | '%' ) { PRCH; } )? cast_expression
	;
	
cast_expression
	: unary_expression
	| '(' { PRCH; } type_name ')' { PRCH; } cast_expression
	;
	
unary_expression
	: postfix_expression
	| ( INC_OP | DEC_OP ) unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF '(' { PRCH; } type_name ')' { PRCH; }
	;
	
unary_operator
	: (BIT_AND | '*' | '+' | '-' | '~' | '!') { PRCH; }
	;
	
postfix_expression
	: primary_expression
	| postfix_expression ( '[' { PRCH; } expression ']' { PRCH; } | '(' { PRCH; } ( argument_expression_list )? ')' { PRCH; } | '.' { PRCH; } id | PTR_OP { fputs("->", f); } id | INC_OP { fputs("++", f); } | DEC_OP { fputs("--", f); } )
	;
	
primary_expression
	: id
	| constant
	| STRING { fprintStringConst(f, yylval.s); }
	| '(' { PRCH; } expression ')' { PRCH; }
	;
	
argument_expression_list
	: ( argument_expression_list ',' { PRCHS; } )? assignment_expression
	;
	
constant
	: INTCONST { fprintf(f, "$%u$", yylval.i); }
	| CHARACTER { fprintStringConst(f, yylval.s); }
	| FLOATCONST { fprintf(f, "$%f$", yylval.d); }
	| id /* enumeration-constant..? haax */
	;
	
id
	: IDENTIFIER { fprintIdentifier(f, yylval.s); }
	;
