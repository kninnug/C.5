%prelude{
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "parser.h"
	
	extern FILE * f;
}

%token AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, 
	DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, 
	RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, 
	UNSIGNED, VOID, VOLATILE, WHILE, CONSTANT, STRING, ELLIPSIS, 
	ASSIGN, COMPARE, ARIT_OP, INC_OP, DEC_OP, PTR_OP, LOGICAL_OR, LOGICAL_AND, IDENTIFIER, 
	PREPROC, BIT_OR, BIT_AND, BIT_XOR, SHIFT, INCLUDE, CHARACTER, FLOATCONST, INTCONST;

/* Rules */
translation_unit
	: external_declaration
	| translation_unit external_declaration
	;
	
external_declaration
	: function_definition
	| declaration
	;
	
function_definition
	: ( declaration_specifiers )? declarator ( declaration_list )? compound_statement
	;
	
declaration
	: declaration_specifiers ( init_declarator_list )? ';' { fputs(";\\\\\n", f); }
	;
	
declaration_list
	: ( declaration_list )? declaration
	;
	
declaration_specifiers
	: ( storage_class_specifier | type_specifier | type_qualifier ) ( declaration_specifiers )?
	;

storage_class_specifier
	: ( AUTO<s>
	| REGISTER<s>
	| STATIC<s>
	| EXTERN<s>
	| TYPEDEF<s> ) { fprintf(f, "{\\bf %s}", s.s); }
	;
	/*typedef-name removed*/
type_specifier
	: ( VOID<s>
	| CHAR<s>
	| SHORT<s>
	| INT<s>
	| LONG<s>
	| FLOAT<s>
	| DOUBLE<s>
	| SIGNED<s>
	| UNSIGNED<s> ) { fprintf(f, "{\\bf %s}", s.s); }
	| struct_or_union_specifier | enum_specifier
	;
	
type_qualifier
	: ( CONST<s>
	| VOLATILE<s> ) { fprintf(f, "{\\bf %s}", s.s); }
	;

struct_or_union_specifier
	: struct_or_union ( IDENTIFIER )? '{' { fputs("\\{\\\\\n", f); } struct_declaration_list '}' { fputs("\\}\\\\\n", f); }
	| struct_or_union IDENTIFIER
	;
	
struct_or_union
	: ( STRUCT<s> | UNION<s> ) { fprintf(f, "{\\bf %s}", s.s); }
	;
	
struct_declaration_list
	: ( struct_declaration_list )? struct_declaration 
	;
	
init_declarator_list
	: ( init_declarator_list ',' )? init_declarator
	;
	
init_declarator
	: ( declarator '=' )? initializer
	;
	
struct_declaration
	: specifier_qualifier_list struct_declarator_list ';' { fputs(";\\\\\n", f); }
	;

specifier_qualifier_list
	: ( type_specifier | type_qualifier ) ( specifier_qualifier_list )?
	;

struct_declarator_list
	: ( struct_declarator_list ',' )? struct_declarator
	;
	
struct_declarator
	: declarator
	| ( declarator )? ':' constant_expression
	;

enum_specifier
	: ENUM ( IDENTIFIER )? { fputs("\\{\\\\\n", f); } '{' enumerator_list '}' { fputs("\\}\\\\\n", f); }
	| ENUM IDENTIFIER
	;
	
enumerator_list
	: ( enumerator_list ',' )? enumerator
	;
	
enumerator
	: IDENTIFIER ( '=' constant_expression )?
	;
	
declarator
	: ( pointer )? direct_declarator
	;
	
direct_declarator
	: IDENTIFIER  {printf("Identifier within declarator: %s\n", yylval.s);}
	| '(' declarator ')' {printf("iets met haakjes\n");}
	| direct_declarator ( '[' ( constant_expression )? ']' | '(' parameter_type_list ')' | '(' ( identifier_list )? ')' ) {printf("nog iets met haakjes\n");}
	;
	
pointer
	: '*' ( type_qualifier_list )? ( pointer )?
	;
	
type_qualifier_list
	: ( type_qualifier_list )? type_qualifier
	;
	
parameter_type_list
	: parameter_list ( ',' ELLIPSIS )?
	;

parameter_list
	: ( parameter_list ',' )? parameter_declaration
	;
	
parameter_declaration
	: declaration_specifiers ( declarator | ( abstract_declarator )? )
	;
	
identifier_list
	: ( identifier_list ',' )? IDENTIFIER
	;
	
initializer
	: assignment_expression
	| '{' { fputs("\\{\\\\\n", f); } initializer_list ( ',' )? '}' { fputs("\\}\\\\\n", f); }
	;
	
initializer_list
	: ( initializer_list ',' )? initializer
	;
	
type_name
	: specifier_qualifier_list ( abstract_declarator )?
	;
	
abstract_declarator
	: pointer
	| ( pointer )? direct_abstract_declarator
	;
	
direct_abstract_declarator
	: '(' abstract_declarator ')'
	| ( direct_abstract_declarator )? ( '[' ( constant_expression )? ']' | '(' ( parameter_type_list )? ')' )
	;
	
typedef_name
	: IDENTIFIER
	;
	
statement
	: labeled_statement
	| expression_statement
	| compound_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;
	
labeled_statement
	: IDENTIFIER ':' statement	/* warning: labels & GOTO's make Dijkstra angry! */
	| CASE constant_expression ':' statement
	| DEFAULT ':' statement
	;
	
expression_statement
	: ( expression )? ';' { fputs(";\\\\\n", f); }
	;
	
compound_statement
	: '{' { fputs("\\{\\\\\n", f); } ( declaration_list )? ( statement_list )? '}' { fputs("\\}\\\\\n", f); }
	;
	
statement_list
	: ( statement_list )? statement
	;
	
selection_statement
	: IF '(' expression ')' statement ( ELSE statement )?
	| SWITCH '(' expression ')' statement
	;

iteration_statement
	: WHILE '(' expression ')' statement
	| DO statement WHILE '(' expression ')' ';' { fputs(";\\\\\n", f); }
	| FOR '(' ( expression )? ';' ( expression )? ';' ( expression )? ')' statement
	;
	
jump_statement
	: GOTO IDENTIFIER ';' { fputs(";\\\\\n", f); } /* warning: labels & GOTO's make Dijkstra angry! */
	| CONTINUE ';' { fputs(";\\\\\n", f); }
	| BREAK ';' { fputs(";\\\\\n", f); }
	| RETURN ( expression )? ';' { printf("Return\n"); fputs(";\\\\\n", f); }
	;
	
expression
	: ( expression ',' )? assignment_expression
	;

assignment_expression
	: conditional_expression
	| unary_expression assignment_operator assignment_expression
	;
	
assignment_operator
	: ASSIGN 
	| '='
	;
	
conditional_expression
	: logical_OR_expression ( '?' expression ':' conditional_expression )?
	;
	
constant_expression
	: conditional_expression
	;
	
logical_OR_expression
	: ( logical_OR_expression LOGICAL_OR )? logical_AND_expression
	;
	
logical_AND_expression
	: ( logical_AND_expression LOGICAL_AND )? inclusive_OR_expression
	;

inclusive_OR_expression
	: ( inclusive_OR_expression BIT_OR )? exclusive_OR_expression
	;
	
exclusive_OR_expression
	: ( exclusive_OR_expression BIT_XOR )? AND_expression
	;
	
AND_expression
	: (AND_expression BIT_AND )? equality_expression
	;
	
equality_expression
	: ( equality_expression COMPARE )? shift_expression
	;

shift_expression
	: (shift_expression SHIFT )? additive_expression
	;
	
additive_expression
	: ( additive_expression ( '+' | '-' ) )? multiplicative_expression
	;
	
multiplicative_expression
	: ( multiplicative_expression ( '*' | '/' | '%' ) )? cast_expression
	;
	
cast_expression
	: unary_expression
	| '(' type_name ')' cast_expression
	;
	
unary_expression
	: postfix_expression
	| ( INC_OP | DEC_OP ) unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF '(' type_name ')'
	;
	
unary_operator
	: '&' | '*' | '+' | '-' | '~' | '!'
	;
	
postfix_expression
	: primary_expression
	| postfix_expression ( '[' expression ']' | '(' ( argument_expression_list )? ')' | '.' IDENTIFIER | PTR_OP IDENTIFIER | INC_OP | DEC_OP )
	;
	
primary_expression
	: IDENTIFIER
	| constant
	| STRING { fprintf(f, "\"%s\"\n", yylval.s); }
	| '(' expression ')'
	;
	
argument_expression_list
	: ( argument_expression_list ',' )? assignment_expression
	;
	
constant
	: INTCONST {printf("intconst: %lu\n", yylval.i); fprintf(f, "$ %u $\n", yylval.i); }
	| CHARACTER 
	| FLOATCONST 
	| IDENTIFIER /* enumeration-constant..? haax */ { printf("Constant\n"); }
	;
