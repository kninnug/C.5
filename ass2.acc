%prelude{
	#include <stdio.h>
	#include <stdlib.h>
}

%token AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, 
	DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, 
	RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, 
	UNSIGNED, VOID, VOLATILE, WHILE, CONSTANT, STRING, ELLIPSIS, 
	ASSIGN, COMPARE, ARIT_OP, INC_OP, DEC_OP, PTR_OP, LOGICAL_OR, LOGICAL_AND, IDENTIFIER, 
	PREPROC, BIT_OR, BIT_AND, BIT_XOR, SHIFT, INCLUDE, CHARACTER, FLOATCONST, INTCONST;

/* Rules */
translation_unit
	: external_declaration
	| translation_unit external_declaration
	;
	
external_declaration
	: function_definition
	| declaration
	;
	
function_definition
	: ( declaration_specifiers )? declarator ( declaration_list )? compound_statement
	;
	
declaration
	: declaration_specifiers ( init_declarator_list )? ';' 
	;
	
declaration_list
	: ( declaration_list )? declaration
	;
	
declaration_specifiers
	: ( storage_class_specifier | type_specifier | type_qualifier ) ( declaration_specifiers )?
	;

storage_class_specifier
	: AUTO | REGISTER | STATIC | EXTERN | TYPEDEF
	;
	
type_specifier
	: VOID | CHAR | SHORT | INT | LONG | FLOAT | DOUBLE | SIGNED | UNSIGNED
	| struct_or_union_specifier | enum_specifier | typedef_name
	;
	
type_qualifier
	: CONST | VOLATILE
	;

struct_or_union_specifier
	: struct_or_union ( IDENTIFIER )? '{' struct_declaration_list '}'
	| struct_or_union IDENTIFIER
	;
	
struct_or_union
	: STRUCT | UNION
	;
	
struct_declaration_list
	: ( struct_declaration_list )? struct_declaration 
	;
	
init_declarator_list
	: ( init_declarator_list ',' )? init_declarator
	;
	
init_declarator
	: ( declarator '=' )? initializer
	;
	
struct_declaration
	: specifier_qualifier_list struct_declarator_list ';'
	;

specifier_qualifier_list
	: ( type_specifier | type_qualifier ) ( specifier_qualifier_list )?
	;

struct_declarator_list
	: struct_declarator
	| struct_declarator_list ',' struct_declarator
	;
	
struct_declarator
	: declarator
	| ( declarator )? ':' constant_expression
	;

enum_specifier
	: ENUM ( IDENTIFIER )? '{' enumerator_list '}'
	| ENUM IDENTIFIER
	;
	
enumerator_list
	: ( enumerator_list ',' )? enumerator
	;
	
enumerator
	: IDENTIFIER ( '=' constant_expression )
	;
	
declarator
	: ( pointer )? direct_declarator
	;
	
direct_declarator
	: IDENTIFIER
	| '(' declarator ')'
	| direct_declarator ( '[' ( constant_expression )? ']' | '(' parameter_type_list ')' | '(' ( IDENTIFIER_list )? ')' )
	;
	
pointer
	: '*' ( type_qualifier_list )? ( pointer )?
	;
	
type_qualifier_list
	: ( type_qualifier_list )? type_qualifier
	;
	
parameter_type_list
	: parameter_list ( ',' ELLIPSIS )
	;

parameter_list
	: ( parameter_list ',' )? parameter_declaration
	;
	
parameter_declaration
	: declaration_specifiers ( declarator | ( abstract_declarator )? )
	;
	
IDENTIFIER_list
	: ( IDENTIFIER_list ',' )? IDENTIFIER
	;
	
initializer
	: assignment_expression
	| '{' initializer_list ( ',' )? '}'
	;
	
initializer_list
	: ( initializer_list ',' )? initializer
	;
	
type_name
	: specifier_qualifier_list ( abstract_declarator )?
	;
	
abstract_declarator
	: pointer
	| ( pointer )? direct_abstract_declarator
	;
	
direct_abstract_declarator
	: '(' abstract_declarator ')'
	| ( direct_abstract_declarator )? ( '[' ( constant_expression )? ']' | '(' ( parameter_type_list )? ')' )
	;
	
typedef_name
	: IDENTIFIER
	;
	
statement
	: labeled_statement
	| expression_statement
	| compound_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;
	
labeled_statement
	: IDENTIFIER ':' statement	/* warning: labels & GOTO's make Dijkstra angry! */
	| CASE constant_expression ':' statement
	| DEFAULT ':' statement
	;
	
expression_statement
	: ( expression )? ';'
	;
	
compound_statement
	: '{' ( declaration_list )? ( statement_list )? '}'
	;
	
statement_list
	: ( statement_list )? statement
	;
	
selection_statement
	: IF '(' expression ')' statement ( ELSE statement )?
	| SWITCH '(' expression ')' statement
	;

iteration_statement
	: WHILE '(' expression ')' statement
	| DO statement WHILE '(' expression ')' ';'
	| FOR '(' ( expression )? ';' ( expression )? ';' ( expression )? ')' statement
	;
	
jump_statement
	: GOTO IDENTIFIER ';'	/* warning: labels & GOTO's make Dijkstra angry! */
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ( expression )? ';'
	;
	
expression
	: ( expression ',' )? assignment_expression
	;

assignment_expression
	: conditional_expression
	| unary_expression assignment_operator assignment_expression
	;
	
assignment_operator
	: ASSIGN 
	| '='
	;
	
conditional_expression
	: logical_OR_expression ( '?' expression ':' conditional_expression )?
	;
	
constant_expression
	: conditional_expression
	;
	
logical_OR_expression
	: ( logical_OR_expression LOGICAL_OR )? logical_AND_expression
	;
	
logical_AND_expression
	: ( logical_AND_expression LOGICAL_AND )? inclusive_OR_expression
	;

inclusive_OR_expression
	: ( inclusive_OR_expression BIT_OR )? exclusive_OR_expression
	;
	
exclusive_OR_expression
	: ( exclusive_OR_expression BIT_XOR )? AND_expression
	;
	
AND_expression
	: (AND_expression BIT_AND )? equality_expression
	;
	
equality_expression
	: ( equality_expression COMPARE )? shift_expression
	;

shift_expression
	: (shift_expression SHIFT )? additive_expression
	;
	
additive_expression
	: ( additive_expression ( '+' | '-' ) )? multiplicative_expression
	;
	
multiplicative_expression
	: ( multiplicative_expression ( '*' | '/' | '%' ) )? cast_expression
	;
	
cast_expression
	: unary_expression
	| '(' type_name ')' cast_expression
	;
	
unary_expression
	: postfix_expression
	| ( INC_OP | DEC_OP ) unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF '(' type_name ')'
	;
	
unary_operator
	: '&' | '*' | '+' | '-' | '~' | '!'
	;
	
postfix_expression
	: primary_expression
	| postfix_expression ( '[' expression ']' | '(' ( argument_expression_list )? ')' | '.' IDENTIFIER | PTR_OP IDENTIFIER | INC_OP | DEC_OP )
	;
	
primary_expression
	: IDENTIFIER
	| constant
	| STRING
	| '(' expression ')'
	;
	
argument_expression_list
	: ( argument_expression_list ',' )? assignment_expression
	;
	
constant
	: INTCONST | CHARACTER | FLOATCONST | IDENTIFIER /* enumeration-constant..? haax */
	;