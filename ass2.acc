%prelude{
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "parser.h"
	
	extern FILE * f;
	
	void fprintStringConst(FILE * f, char * s){
		while(*s){
			if(*s == '\\') fputs("\\textbackslash ", f);
			else if(*s == '%') fputs("\\%", f);
			else if(*s == '$') fputs("\\$", f);
			else if(*s == '>') fputs("$>$", f);
			else if(*s == '<') fputs("$<$", f);
			else if(*s == '{') fputs("\\{", f);
			else if(*s == '}') fputs("\\}", f);
			else if(*s == '&') fputs("\\&", f);
			else fputc(*s, f);
			s++;
		}
	}
	
	void fprintIdentifier(FILE * f, char * s){
		while(*s){
			if(*s == '_') fputc('\\', f), fputc('_', f);
			else fputc(*s, f);
			s++;
		}
	}
	
	void prCh(FILE * f, int c){
		switch(c){
			case '&':
			case '%':
			case '{':
			case '}':
				fputc('\\', f);
				fputc(c, f);
			break;
			case '<':
			case '>':
				fputc('$', f);
				fputc(c, f);
				fputc('$', f);
			break;
			default:
				fputc(c, f);
		}
	}
	
	void fprintCompare(FILE * f, int st){
		switch(st){
			case COMPARE_EQUAL: fputs("\\ $==$\\ ", f); break;
			case COMPARE_UNEQUAL: fputs("\\ $\\neq$\\ ", f); break;
			case COMPARE_LEQ: fputs("\\ $\\leq$\\ ", f); break;
			case COMPARE_GREQ: fputs("\\ $\\geq$\\ ", f); break;
			case COMPARE_GREATER: fputs("\\ $>$\\ ", f); break;
			case COMPARE_LESS: fputs("\\ $<$\\ ", f); break;
			
			case ASSIGN_AND: fputs("\\ $\\&=$\\ ", f); break;
			case ASSIGN_DIVIDE: fputs("\\ $/=$\\ ", f); break;
			case ASSIGN_MINUS: fputs("\\ $-=$\\ ", f); break;
			case ASSIGN_MOD: fputs("\\ $\\%=$\\ ", f); break;
			case ASSIGN_OR: fputs("\\ $|=$\\ ", f); break;
			case ASSIGN_PLUS: fputs("\\ $+=$\\ ", f); break;
			case ASSIGN_SHLEFT: fputs("\\ $<<=$\\ ", f); break;
			case ASSIGN_SHRIGHT: fputs("\\ $>>=$\\ ", f); break;
			case ASSIGN_XOR: fputs("\\ $\\^=$\\ ", f); break;
		}
	}
	
	#define PRCH prCh(f, yylval.c)
	#define PRCHS PRCH, fputs("\\ ", f)
	#define SPRCHS fputs("\\ ", f), PRCHS
	#define PRS fprintStringConst(f, yylval.s)
	#define PRKW fprintf(f, "{\\bf %s} ", yylval.s)
	#define PRSC fputs(";\\\\\n", f)
}

%token AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, 
	DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, 
	RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, 
	UNSIGNED, VOID, VOLATILE, WHILE, CONSTANT, STRING, ELLIPSIS, 
	ASSIGN, COMPARE, ARIT_OP, INC_OP, DEC_OP, PTR_OP, LOGICAL_OR, LOGICAL_AND, IDENTIFIER, 
	PREPROC, BIT_OR, BIT_AND, BIT_XOR, SHIFT, BIT_NOT, INCLUDE, CHARACTER, FLOATCONST, INTCONST;

/* Rules */
translation_unit
	: ( external_declaration )*
	;
	
external_declaration
	: function_definition
	| declaration
	;
	
function_definition
	: ( declaration_specifiers )? declarator ( declaration_list )? ( ';' { fputs(";\\\\\\\n", f); } | compound_statement { fputs("\\\\\n", f); } )
	;
	
declaration
	: declaration_specifiers ( init_declarator_list )? ';' { PRSC; }
	;
	
declaration_list
	: declaration ( declaration )*
	;
	
declaration_specifiers
	: ( storage_class_specifier | type_specifier | type_qualifier )* { fputc(' ', f); }
	;

storage_class_specifier
	: ( AUTO
	| REGISTER
	| STATIC
	| EXTERN
	| TYPEDEF ) { PRKW; }
	;

/*typedef-name removed*/
type_specifier
	: ( VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED ) { PRKW; }
	| struct_or_union_specifier | enum_specifier
	| id
	;
	
type_qualifier
	: ( CONST
	| VOLATILE ) { PRKW; }
	;

struct_or_union_specifier
	: struct_or_union ( id )? '{' { fputs("\\{\\\\\n", f); } struct_declaration_list '}' { fputs("\\}\\\\\n", f); }
	| struct_or_union id
	;
	
struct_or_union
	: ( STRUCT | UNION ) { PRKW; }
	;
	
struct_declaration_list
	: ( struct_declaration_list )? struct_declaration 
	;
	
init_declarator_list
	: ( init_declarator_list ',' { PRCHS; } )? init_declarator
	;
	
init_declarator
	: ( declarator '=' { SPRCHS; } )? initializer
	;
	
struct_declaration
	: specifier_qualifier_list struct_declarator_list ';' { PRSC; }
	;

specifier_qualifier_list
	: ( type_specifier | type_qualifier ) ( specifier_qualifier_list )?
	;

struct_declarator_list
	: ( struct_declarator_list ',' { PRCHS; } )? struct_declarator
	;
	
struct_declarator
	: declarator
	| ( declarator )? ':' { PRCH; } constant_expression
	;

enum_specifier
	: ENUM { PRKW; } ( id )? { fputs("\\{\\\\\n", f); } '{' enumerator_list '}' { fputs("\\}\\\\\n", f); }
	| ENUM { PRKW; } id
	;
	
enumerator_list
	: ( enumerator_list ',' { PRCHS; } )? enumerator
	;
	
enumerator
	: id ( '=' { SPRCHS; } constant_expression )?
	;
	
declarator
	: ( pointer )? direct_declarator
	;
	
direct_declarator
	: id
	| '(' { PRCH; } declarator ')' { PRCH; }
	| direct_declarator ( '[' { PRCH; } ( constant_expression )? ']' { PRCH; } | '(' { PRCH; } parameter_type_list ')' { PRCH; } | '(' { PRCH; } ( identifier_list )? ')' { PRCH; } )
	;
	
pointer
	: '*' { PRCH; } ( type_qualifier_list )? ( pointer )?
	;
	
type_qualifier_list
	: ( type_qualifier_list )? type_qualifier
	;
	
parameter_type_list
	: parameter_list ( ',' { PRCHS; } ELLIPSIS )?
	;

parameter_list
	: ( parameter_list ',' { PRCHS; } )? parameter_declaration
	;
	
parameter_declaration
	: declaration_specifiers ( declarator | ( abstract_declarator )? )
	;
	
identifier_list
	: ( identifier_list ',' { PRCHS; } )? id
	;
	
initializer
	: assignment_expression
	| '{' { fputs("\\{", f); } initializer_list ( ',' )? '}' { fputs("\\}", f); }
	;
	
initializer_list
	: ( initializer_list ',' { PRCHS; } )? initializer
	;
	
type_name
	: specifier_qualifier_list ( abstract_declarator )?
	;
	
abstract_declarator
	: pointer
	| ( pointer )? direct_abstract_declarator
	;
	
direct_abstract_declarator
	: '(' { PRCH; } abstract_declarator ')' { PRCH; }
	| ( direct_abstract_declarator )? ( '[' { PRCH; } ( constant_expression )? ']' { PRCH; } | '(' { PRCH; } ( parameter_type_list )? ')' { PRCH; } )
	;
	
typedef_name
	: id
	;
	
statement
	: labeled_statement
	| expression_statement
	| compound_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;
	
labeled_statement
	: id ':' { PRCH; fputc(' ', f); } statement	/* warning: labels & GOTO's make Dijkstra angry! */
	| CASE { PRKW; } constant_expression ':' { PRCH; fputc(' ', f); } statement
	| DEFAULT { PRKW; } ':' { PRCH; fputc(' ', f); } statement
	;
	
expression_statement
	: ( expression )? ';' { PRSC; }
	;
	
compound_statement
	: '{' { fputs("\\{\\+\\\\\n", f); } ( declaration_list )? ( statement_list )? '}' { fputs("\\<\\}\\-\\\\\n", f); }
	;
	
statement_list
	: ( statement_list )? statement
	;
	
selection_statement
	: IF { PRKW; } '(' { PRCH; } expression ')' { PRCH; } statement ( ELSE { PRKW; } statement )?
	| SWITCH { PRKW; } '(' { PRCH; } expression ')' { PRCH; } statement
	;

iteration_statement
	: WHILE { PRKW; } '(' { PRCH; } expression ')' { PRCH; } statement
	| DO { PRKW; } statement WHILE { PRKW; } '(' { PRCH; } expression ')' { PRCH; } ';' { PRSC; }
	| FOR { PRKW; } '(' { PRCH; } ( expression )? ';' { PRCHS; } ( expression )? ';' { PRCHS; } ( expression )? ')' { PRCH; } statement
	;
	
jump_statement
	: GOTO { PRKW; } id ';' { PRSC; } /* warning: labels & GOTO's make Dijkstra angry! */
	| CONTINUE { PRKW; } ';' { PRSC; }
	| BREAK { PRKW; } ';' { PRSC; }
	| RETURN { PRKW; } ( expression )? ';' { printf("Return\n"); PRSC; }
	;
	
expression
	: ( expression ',' { PRCHS; } )? assignment_expression
	;

assignment_expression
	: conditional_expression
	| unary_expression assignment_operator assignment_expression
	;
	
assignment_operator
	: ASSIGN { fprintCompare(f, yylval.subtype); }
	| '=' { SPRCHS; }
	;
	
conditional_expression
	: logical_OR_expression ( '?' { PRCH; } expression ':' { PRCH; } conditional_expression )?
	;
	
constant_expression
	: conditional_expression
	;
	
logical_OR_expression
	: ( logical_OR_expression LOGICAL_OR { fputs("\\ $\\vee$\\ ", f); } )? logical_AND_expression
	;
	
logical_AND_expression
	: ( logical_AND_expression LOGICAL_AND { fputs("\\ $\\wedge$\\ ", f); } )? inclusive_OR_expression
	;

inclusive_OR_expression
	: ( inclusive_OR_expression BIT_OR { SPRCHS; } )? exclusive_OR_expression
	;
	
exclusive_OR_expression
	: ( exclusive_OR_expression BIT_XOR { SPRCHS; } )? AND_expression
	;
	
AND_expression
	: (AND_expression BIT_AND { SPRCHS; } )? equality_expression
	;
	
equality_expression
	: ( equality_expression COMPARE { fprintCompare(f, yylval.subtype); } )? shift_expression
	;

shift_expression
	: (shift_expression SHIFT { yylval.subtype == SHIFT_LEFT ? fputs("\\ $<<$\\ ", f) : fputs("\\ $>>$\\ ", f); } )? additive_expression
	;
	
additive_expression
	: ( additive_expression ( '+' | '-' ) { SPRCHS; } )? multiplicative_expression
	;
	
multiplicative_expression
	: ( multiplicative_expression ( '*' | '/' | '%' ) { SPRCHS; } )? cast_expression
	;
	
cast_expression
	: unary_expression
	| '(' { PRCH; } type_name ')' { PRCH; } cast_expression
	;
	
unary_expression
	: postfix_expression
	| ( INC_OP { fputs("++", f); } | DEC_OP { fputs("--", f); } ) unary_expression
	| unary_operator cast_expression
	| SIZEOF { PRKW; } unary_expression
	| SIZEOF { PRKW; } '(' { PRCH; } type_name ')' { PRCH; }
	;
	
unary_operator
	: (BIT_AND | '*' | '+' | '-' | '~' | '!' | BIT_NOT | BIT_OR | BIT_XOR) { PRCH; }
	;
	
postfix_expression
	: primary_expression
	| postfix_expression ( '[' { PRCH; } expression ']' { PRCH; } 
		| '(' { PRCH; } ( argument_expression_list )? ')' { PRCH; } 
		| '.' { PRCH; } id 
		| PTR_OP { fputs("$\\rightarrow$", f); } id 
		| INC_OP { fputs("++", f); } 
		| DEC_OP { fputs("--", f); } )
	;
	
primary_expression
	: id
	| constant
	| STRING { fprintStringConst(f, yylval.s); }
	| '(' { PRCH; } expression ')' { PRCH; }
	;
	
argument_expression_list
	: ( argument_expression_list ',' { PRCHS; } )? assignment_expression
	;
	
constant
	: INTCONST { fprintf(f, "$%u$", yylval.i); }
	| CHARACTER { fprintStringConst(f, yylval.s); }
	| FLOATCONST { fprintf(f, "$%f$", yylval.d); }
	| id /* enumeration-constant..? haax */
	;
	
id
	: IDENTIFIER { fprintIdentifier(f, yylval.s); }
	;
